# pid.py / pid.h

## 0. PID制御とは

PID制御とはP制御、I制御、D制御の組み合わせによって行われる制御のことです。

P制御(Proportional)：比例制御  
I制御(Integral)：積分制御  
D制御(Differential)：微分制御

これらは目標値と実測値による差分を用いて出力を行う者です。例えば風呂の温度を調整したいときに、風呂の温度の目標値に対しての実測値を入力とし、出力として風呂に追加する熱湯と水の比率を得る、というような使われ方が主です。
ロボットを作る際に、目標値に実測値を近づけるためにPID制御をもちいることが多々あります。
### P制御
比例制御のみによる制御のことです。比例制御とは目標値から実測値を引いたエラーに比例した出力がなされます。この比例制御を続けると実測値は目標値に近づこうとはするものの、
エラーを修正しようとしすぎて目標値を追い越してしまうことが多くあります。この追い越しが蛇行を引き起こすことがあり、比例制御のみでの制御は勧めません。

### I制御
積分制御のみによる制御のことです。積分制御のみで動かすロボットはほとんどありませんが、積分は他の制御と組み合わせることによって絶大な効果を発揮することができます。
積分制御では基本的に今までのエラーの蓄積に比例した出力をします。この制御では今まで動いてきた動きをなるべく保とうとする傾向があり、外力が加わる場合に特に有効だと言えます。
風呂の例を出すと、風呂は常に40度を目指そうとしていても室温が20度だったら継続的に風呂の温度を室温まで引き下ろそうとする力が働くわけです。この力をP制御で抑えようとすると蛇行が激しくなってしうため、
I制御によって常に熱湯の割合をいくらか底上げし続ける必要があります。また、ラインフォローなどでラインを見失った際に今まで曲がってきた動きからI制御によってラインに引き戻すことができることもあります。
他の制御との兼ね合いが大切な制御です。

### D制御
微分制御のみによる制御のことです。これも微分制御のみを用いるものはほとんどありません。微分制御ではエラーの微分に比例した出力をします。
もっと端的に言うと、一回前の処理の際のエラーと今のエラーの差を、処理の間の時間で割った値であり、どれだけエラーが変化したかを表します。
この制御は基本的にP制御の振動を抑えるような働きを主にします。

### PD制御
PD制御ではP制御とD制御の組み合わせによる制御のことです。基本的に継続的な外力がない場合に有効で、比例制御の振動を微分制御が抑える、という者になっています。
ここでP制御とD制御の割合を適切に決めることが大切になります。

### PID制御
PID制御ではP制御とI制御とD制御の組み合わせによる制御のことです。PD制御にI制御を加えたもので、外力などにも適応でき、かつそれぞれの制御に適切な重みをかけることによって振動の少ない制御を行うことができます。

### ゲインとは
ゲインとは、それぞれの制御にかける定数のことであり、重みとも考えられます。どの制御がどのくらい出力に影響するのかを決定し、振動がなくエラーを無くすにはゲインの調整が最も重要といっても過言ではありません。
P制御、I制御、D制御のゲインはそれぞれKp, Ki, Kdと表記されることが一般的です。

## 1. 使い方 (pid.py)
### import
```python
from pid import *
```
プログラムの初めでちゃんとインポートしてください。もしファイルの位置がちがったりしたらsysかなんかでうまい具合にimportしてください。

### initialize
```python
kp = 0.5
ki = 0.02
kd = 0.05
myPID = PIDController(kp, ki, kd)
```
ここではmyPIDというオブジェクトを宣言しています。
PIDControllerクラスのコンストラクタには3つの引数があり、それぞれdouble型のkp, ki, kdが入力されることを想定しています。ここで使用しているゲインはあくまでも例です。また、この例のように変数を宣言せず、
```python
myPID = PIDController(0.5, 0.02, 0.05)
```
このように宣言をしてもかまいません。

### start
```python
myPID.start()
```
これはmyPIDのスタートを意味します。なぜスタートしなければ行けないのかというと、積分制御においてエラーを積分する始めの点を設定しなければならないからです。このstart関数は必ずPIDControllerが出力を始める前に呼び出してください。また、積分をリスタートさせたいときにもstart関数を呼び出すとリセットすることができます。  
この関数はロボットが動き始める際に呼び出されることを想定しています。

### update
```python
set_point = 1.0
measured_value = measure() #measure is an imaginary function. Use your own measuring function
output = myPID.update(set_point, measured_value)
```
update関数はPID制御をするのとほとんど同義です。update関数には二つの引数、目標値と実測値があります。それぞれ数の型(double, int, etc...)の入力を想定しており、目標値、実測値の順番での入力をしてください。start関数を呼び出す前にupdate関数を呼び出してしまうとエラーを吐くので、注意してください。  
この関数はロボットのループ処理の中で実行されることを想定しており、この出力は何らかのモーターの出力であったり車の車輪の角度であったりに使用するといいでしょう。

### constants
kp, ki, kdはプログラムの途中でも変更することができます。
```python
myPID.kp = 0.1
myPID.ki = 0.1
myPID.kd = 0.1
```
このようにPIDクラスのkp, ki, kdそれぞれの要素に関して変更することができます。
## 2. 使い方 (pid.h)

### include
```cpp
#include "pid.h"
```
main関数が入っているcppファイルでincludeしてください。pid.hのパスは環境に応じて適宜変えてください。

### initialize

```cpp
double kp = 0.5;
double ki = 0.02;
double kd = 0.05;
PIDController myPID(kp, ki, kd);
```
これでmyPIDというオブジェクトが宣言できます。他にも
```cpp
PIDController myPID(0.5, 0.02, 0.05);
```
などと宣言することもできます。

### start
```cpp
myPID.start();
```
これによりmyPIDがスタートされます。機能はpid.pyと同じです。

### update
```cpp
double set_point = 1.0;
double measured_value = measure(); //measure is an imaginary function. Use your own measuring function
output = myPID.update(set_point, measured_value);
```
これも機能はpid.pyと同じです。

### constants
```cpp
myPID.setKp(0.1);
myPID.setKi(0.1);
myPID.setKd(0.1);
```
このようにして処理の途中でもkp, ki, kdを変更することができます。
```cpp
double currentKp = myPID.getKp();
double currentKi = myPID.getKi();
double currentKd = myPID.getKd();
```
このように現時点でのkp, ki, kdを取得することもできます。
## 3. 設定のコツ

いつか書きます、、、、